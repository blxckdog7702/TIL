# C언어 기초문법

### 식별자(이름)  
- 영문 대소문자, 숫자, 언더스코어만 사용 가능
- 키워드 사용 불가
- 숫자로 시작될 수 없으며, 반드시 영문자나 언더스코어로 시작
- **대소문자 구분**

### 특수식별자  
- __ func__ (현재 함수의 이름)
```
printf("%s\n", __func__);
```

### 변수의 유효범위  
> 1. 변수는 기본적으로 선언된 블럭과 그 하위 블럭에서 사용할 수 있다.
> 2. 하위 블럭에 동일한 이름으로 변수가 선언되면 하위 블럭 내에서는 하위 블럭에서 선언된 변수가 사용된다.

```
#include <stdio.h>
int main (int argc, char * argv[])
{
    int var = 10;
    printf("The value before: %d\n", var);
    {
        int var = 20;
        printf("The value in block: %d\n", var);
    }
    printf("The value after: %d\n", var);
    return 0;
}
```
java는 에러난다.

### static  
```
#include <stdio.h>
int main (int argc, char * argv[])
{
    some_subfunction();
    some_subfunction();
    return 0;
}

int some_subfunction()
{
   static int var = 0;
   var += 10;
   printf ("A variable in subfunction: %d\n", var);
   return 0;
}
```
출력 결과는 10, 20이다.  
함수 내부에서 static이 선언된 경우 그 함수 내부에서만 사용 가능
전역 변수에서 static이 선언된 경우 그 파일 내에서는 전역변수로 사용 가능하지만 다른 파일에서 참조 불가능

### extern  
다른 파일의 전역 변수를 사용할때 선언한다.  
초기화 생략하면 0으로 초기화.  
남발하면 유지보수가 힘들어지므로 최대한 적게 쓰는걸 권장.  
헤더파일에 선언해서 사용하는 방식으로 많이 쓴다.
헤더 파일에서 초기화 할 시, 여러 파일에서 헤더파일을 참조하면 초기화 부분이 여러번 실행되면서 에러 발생.

```  
extern_value.h
extern int ex_value; // extern 선언(초기화는 다른 파일에서 해야함)
```

```
extern_value.c
#include "extern_value.h"
int ex_value = 10; // 변수 선언 + 초기화
```

```
main.c
#include "extern_value.h"
void main()
{
  printf("%d", ex_value); // extern 변수 사용
}
```

### 배열  
선언은 `int arr[size];` 처럼 선언  

### 문자형 데이터  
- 1바이트  
- 문자열 상수는 ""를 이용한다. 끝에 `\0`이 붙어있다.

```
#include <stdio.h>
int main (int argc, char *argv[])
{
    char str1[20] = "Hello World!";
    char str2[]   = "Hello Another World!";
    char *str3    = "Hello The Other World!";

    printf("Str1: %s\n", str1);
    printf("Str2: %s\n", str2);
    printf("Str3: %s\n", str3);

    return 0;
}
```
str1은 20바이트 할당  
str2는 컴파일러가 문자 개수 세서 할당하기 때문에 21바이트 (`\0`포함)  
str3는 포인터 타입이므로 문자열 길이와 상관없이 포인터 타입 만큼 공간을 할당하고, (스태틱 영역에 있는) 문자열의 주소를 값으로 할당받는다.

### 포인터  
- 여러개 선언시 `int *a, *b, *c;` 처럼 일일이 `*` 붙여줘야함

```
int main()
{
    int Num1=50, Num2=100;
    int *pNum1=&Num1;
    int **dpNum1=&pNum1;

    printf("정수형 변수 Num1의 값: %d\n", Num1);
    printf("pNum1이 가리키는 변수의 값: %d\n", *pNum1);
    printf("dpNum1이 가리키는 변수의 값: %d\n\n", **dpNum1);

    *dpNum1=&Num2; // pNum1=&Num2
    printf("정수형 변수 Num2의 값: %d\n", Num2);
    printf("pNum1이 가리키는 변수의 값: %d\n", *pNum1);
    printf("dpNum1이 가리키는 변수의 값: %d\n\n", **dpNum1);

    **dpNum1+=150;
    printf("정수형 변수 Num2의 값: %d\n", Num2);
    printf("pNum1이 가리키는 변수의 값: %d\n", *pNum1);
    printf("dpNum1이 가리키는 변수의 값: %d\n", **dpNum1);

    return 0;
}
```
출력 결과는  
50, 50, 50  
100, 100, 100  
250, 250, 250  

### 포인터 + 배열  
```
int main()
{
    int Array[5]={44,77,64,13,42};
    int *p=&Array[2];

    printf("p가 가리키는 배열의 위치: %d\n", *p);
    printf("p가 가리키는 배열의 위치에서 한칸 앞: %d\n", *(p+1));
    printf("p가 가리키는 배열의 위치에서 두칸 앞: %d\n", *(p+2));
    printf("p가 가리키는 배열의 위치에서 한칸 뒤: %d\n", *(p-1));
    printf("p가 가리키는 배열의 위치에서 두칸 뒤: %d\n", *(p-2));
    return 0;
}
```

### 구조체  
- 선언부 변수부 분리  
```
struct Man {
  char name[50];
  int  age;
  char gender;
  char tel[50];
};

struct Man man;
```

- 선언부와 변수부 결합된 예
```
struct Man {
  char name[50];
  int  age;
  char gender;
  char tel[50];
} man;
```  
이렇게 프로그램 구성을 하면 man이라는 변수의 메모리 공간이 만들어진다. 그러나 문제는 Man의 구조체가 여러 파일에서 사용한다면 구조체의 구조부를 include 하여야 하는데 그렇게 되면 man 변수가 중복된다. 따라서 include을 한번 밖에는 할 수가 없다. 보통 습관적으로 선언부만 헤더 파일로 분리해서 코딩하는 습관이 좋다.  

- `typedef` 키워드와 함께쓰면 `struct` 키워드를 매번 쓰지 않아도 된다.
```  
typedef struct Man {
  char name[50];
  int  age;
  char gender;
  char tel[50];
} Man;

Man *getMan();
```

- 구조체의 포인터  
```
struct point {
   int x;
   int y;
} my_point;

/* To declare p as a pointer of type struct point */
struct point *p = &my_point;

my_point.y = 3; /* struct의 두 번째 변수의 값 변경 */
(*p).x = 8; /* To access the first member of the struct */
p->x = 8; /* Another way to access the first member of the struct */
```
포인터의 표현 방법은 ->와 .이 있다.

-> : 화살표 앞의 변수가 포인터 변수이면 화살표를 사용한다. 위의 예에서 처럼 ()을 사용하면 .을 사용한다.
. : 점 앞의 변수가 포인터가 아닐때 사용한다.
