# 클린 코드  
## 목차  

* [2장 의미있는 이름](#2장-의미있는-이름)
* [3장 함수](#3장-함수)  
* [4장 주석](#4장-주석)
* [5장 형식 맞추기](#5장-형식-맞추기)
* [6장 객체와 자료구조](#6장-객체와-자료구조)
* [7장 오류 처리](#7장-오류-처리)  
* [8장 경계](#8장-경계)
* [9장 단위 테스트](#9장-단위-테스트)
* [10장 클래스](#10장-클래스)
* [11장 시스템](#11장-시스템)
* [12장 창발성(Emergence)](#12장-창발성)
* [13장 동시성](#13장-동시성)
* [17장 냄새와 휴리스틱](#17장-냄새와-휴리스틱)

## 2장 의미있는 이름  
##### 의도를 분명하게 밝혀라  
```
int daySinceCreation;
int elapsedTimeInDay;
int fileAgeInday;
```  

`str1, str2` 대신 `source, destination`을 쓰면 가독성 up

##### 검색하기 쉬운 이름을 써라  
- 통상적으로 이름이 길어질수록 검색하기 쉽다.

##### 인코딩을 피하라  
- 헝가리안 표기법처럼 타입을 변수명에 넣을 필요가 없다.
- 멤버 변수 접두어 넣을 필요 없다. `m_name`
- 인터페이스와 구현 클래스는 `IShapeFactory` 처럼 인터페이스에 표시해주기 보다는 구현 클래스에 `ShapeFactoryImpl` 이라고 나타내는게 낫다.

##### 클래스나 객체 이름  
- 클래스나 객체 이름은 명사나 명사구
- Manager, Processor, Data, Info 등과 같은 단어는 피한다.

##### 메서드 이름  
- 메서드 이름은 동사나 동사구
- set, get, is는 javabean 표준에 따라서 붙인다.
- 생성자를 중복정의 할 때는 정적 팩토리 메서드 이용
```
Complex fulcrumPoint = Complex.FromRealNumber(23.0);
Complex fulcrumPoint = new Complex(23.0);
```
아래 코드보다 위 코드가 좋다.

##### 일관성있는 어휘 사용  
- fetch, retrieve, get을 섞어쓰면? 복잡하지

##### 말장난을 하지 마라  
- add는 둘을 더하는거고, A에 B를 넣는것은 insert나 append라는 이름을 쓰자.

## 3장 함수  
##### 작게 만들어라!  
- if/else/while 등에 들어가는 블록은 한 줄이여야 한다.

##### 함수 당 추상화 수준은 하나로  
- 같은 함수 내에서 추상화 수준이 뒤죽박죽 섞이면 파악하는데 헷갈림

##### Switch case?  
- switch 문은 추상 팩토리 클래스를 구현해서 그 안에 숨긴다.

##### flag 인수는 추하다?  
- 메서드 안에서 이것저것 많이 한다고 공표하는 셈이라 추하다?

##### 부수 효과를 일으키지 마라?  
- 함수에서 한 가지를 하겠다고 명시했는데 그 안에 다른 처리도 끼어들어가 있는 것.

##### 출력 인수  
- 일반적으로 출력 인수는 피해야 한다. 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택한다.  
```
appendFooter(s);
public void appendFooter(StringBuffer report);
```
위 코드만 보고 s가 무엇인지 위해서 함수 선언부를 찾아보게 된다.
그러므로 아래 코드처럼 바꾸는게 좋다.  
```
report.appendFooter();
```

##### trycatch  
- try/catch 블록은 별도 함수로 뽑아내는 편이 좋다.
- 정상 동작과 오류처리 동작을 분리한다.


## 4장 주석  
##### 주석은 나쁜 코드를 보완하지 못한다.  
- 그 시간에 코드를 다시 고치는게 낫다.

##### 좋은 주석  
- 코드에 표현할 수 없는 부분만 쓰는게 낫다.
- 또는 결과를 경고하거나 중요성을 강조하는데 쓰인다.
- 법적인 내용을 담고 있는 주석.

##### 나쁜 주석  
- 같은 이야기를 반복하거나 주석이 또 다른 의문을 들게한다.
- 오해할 여지를 남긴다.

## 5장 형식 맞추기  
##### 수직 거리  
- 서로 밀접한 개념은 세로로 가까이 둬야한다.
- 서로 멀리 떨어져있으면 소스를 위아래로 뒤지게 되니까.

##### 변수 선언  
- 변수는 사용하는 위치에 최대한 가까이 선언한다.
- 인스턴스 변수는 클래스 맨 처음에 선언한다. 변수 간 세로로 거리를 두지 않는다.

##### 함수 선언  
- 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.
- 되도록 호출하는 함수를 호출되는 함수보다 먼저 배치한다.

## 6장 객체와 자료구조  

##### 자료 추상화  
- 변수에 대한 단순한 get,set은 구현을 노출시킬 뿐이다.(직교 좌표계, 극 좌표계)
- 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스이다.

##### 자료/객체 비대칭  
- 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 제공.
- 자료구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않음.
- 객체와 자료구조는 근본적으로 양분된다.
- 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 모든 함수를 고쳐야 한다.
- 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.

##### 디미터 법칙  
- 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙.
- 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다, 고 주장한다.
- 클래스 C
- f가 생성한 객체
- f 인수로 넘어온 객체
- C 인스턴스 변수에 저장된 객체
- 낮선 사람은 경계하고 친구랑만 놀라는 의미
```
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```
같은 코드를 쓰지 말라는 것. 이를 기차 충돌(train wreck) 이라고 부른다.  
다음과 같이 코드를 나누는 편이 좋다.  
```
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```

## 7장 오류 처리  
##### 오류 코드보다 예외를 사용하라  
- 오류가 발생하면 예외를 던지는 편이 호출자 코드가 깔끔해진다.

##### 호출자를 고려해 예외 클래스를 작성하라  
- 오류 분류를 잘만 해놓아도 깔끔하게 예외 처리가 가능
- wrapper 클래스를 이용해서 관련 예외를 하나로 처리
```
//wrapper 클래스
LocalPort port = new LocalPort(12);
try {
  port.open();
} catch {
  //blah...
}
```

##### null을 반환하지 마라  
- null을 반환하는 것은 일거리를 늘릴 뿐 아니라 호출자에게 문제를 떠넘긴다.
- null을 반환하면 꼭 null 체크를 해줘야한다.
- 예외를 던지거나 특수 사례 개체 ex)`return Collections.emptyList()`를 반환하는 것이 좋다.

##### null을 전달하지 마라  
- null인 가능성이 있는 객체를 전달하기 이전에 null 체크가 필요하다.

## 8장 경계  
소프트웨어를 개발할 때 모든 기능을 직접 개발하는 경우는 드물다. 내가 만든 코드와 다른 팀에서 만든 코드를 통합할 때 경계를 깔끔하게 통합하는 방법에 대해서 말한다.  
##### 학습테스트  
우리 쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 것을 **학습 테스트** 라고 부른다.  

##### 분리  
- 경계에 위치하는 코든느 깔끔히 분리한다.
- 기대치를 정의하는 테스트 케이스도 작성한다.
- 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.
- 새로운 클래스로 경계를 감싸거나 아니면 Adapter 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자.

## 9장 단위 테스트  
##### TDD 법칙 세 가지  
1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

위 세 가지 규칙을 따르면 개발과 테스트가 대략 30초 주기로 묶인다.  

##### 깨끗한 테스트 코드 유지하기  
- 테스트 코드 또한 가독성이 높고 유지 보수성이 높아야한다.

##### F.I.R.S.T  
깨끗한 테스트는 다음 다섯 가지 규칙을 따른다.  
1. Fast : 테스트는 빨라야 한다.
2. Independent : 각 테스트는 서로 의존하면 안 된다.
3. Repeatable : 테스트는 어떤 환경에서도 반복 가능해야 한다. 실제 환경, QA 환경, 버스를 타고 집에 가는 길에 사용하는 노트북 환경에서도 마찬가지다.
4. Self-Validating : 테스트는 bool 값으로 결과를 내야 한다. 성공 아니면 실패다. 통과 여부를 알려고 로그 파일을 읽게 만들어서는 안 된다.
5. Timely : 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.

## 10장 클래스  

##### 클래스 체계  
- 정적 공개 상수 > 정적 비공개 변수 > 비공개 인스턴스 변수
- 변수 목록 다음에는 공개 함수
- 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다.
- 그래서 프로그램은 신문 기사처럼 읽힌다.

##### 클래스는 작아야 한다!  
- 클래스는 작아야한다.
- 클래스 설명은 if, and, or, but을 사용하지 않고 25단어 내외로 가능해야 한다.
- 단일 책임 원칙(Single Responsibility Principle)은 클래스나 모듈을 변결할 이유가 단 하나 뿐이어야 한다는 원칙이다.

##### 응집도  
- 클래스는 인스턴스 변수 수가 적어야 한다.
- 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다.
- 일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다.
- 모든 인스턴스 변수를 메서드마다 사용하는 클래스는 응집도가 가장 높다.
- 응집도를 유지하면 작은 클래스 여럿이 나온다.

##### 변경으로부터 격리  
- 객체지향 프로그래밍 입문에서 구체적인(concrete) 클래스와 추상(abstract) 클래스가 있다고 배웠다.
- 구체적인 클래스는 상세한 구현을 포함한다.
- 추상 클래스는 개념만 포함한다.
- 상세한 구현에 의존하는 코드는 테스트가 어렵다.

Portfolio 클래스는 외부 TokyoStockExchange API를 사용해 포트폴리오 값을 계산한다. 따라서 테스트 코드는 외부 시세 변화에 영향을 받는다. 5분 마다 값이 달라지는 API로 테스트 코드를 짜기란 쉽지 않다.  
Portfolio 클래스에서 TokyoStockExchange API를 직접 호출하는 대신 StockExchange라는 인터페이스를 생성한 후 메서드를 선언한다.

```
public interface StockExchange {
  Money currentPrice(String symbol);
}
```

```
public Portfolio {
  private StockExchange exchange;
  public Portfolio(StockExchange exchange) {
    this.exchange = exchange;
  }
}
```
다음과 같이 개선한 Portfolio 클래스는 TokyoStockExchange라는 상세한 구현 클래스가 아니라 StockExchange 인터페이스에 의존한다. StockExchange 인터페이스는 주식 기호를 받아 현재 주식 가격을 반환한다는 추상적인 개념을 표현한다. 이와 같은 추상화로 실제로 주가를 얻어오는 출처나 얻어오는 방식 등과 같은 구체적인 사실을 모두 숨긴다.

## 11장 시스템  
##### 시스템 제작과 사용을 분리  
> 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는) 준비과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다.  

```
public Service getService() {
  if (service == null)
    service = new MyServiceImpl(...);
  return service;
}
```
위와 같은 구현 방식을 초기화 지연, 또는 계산 지연이라고 한다. 실제로 필요할 때까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않는다. 또한 null 포인터를 반환하지 않는다.  
하지만, getService 메서드가 MyServiceImpl의 생성자 매개변수가 맞지 않으면 MyServiceImpl을 사용하지 않아도 컴파일부터 되지 않는다.  
또한, MyServiceImpl이 무거운 객체라면 단위 테스트를 할 때 적절한 테스트 전용 객체를 service 필드에 할당해야 한다. 그리고 일반 런타임 로직에 객체 생성 로직을 섞어놓은 탓에 모든 실행 경로(service가 null or not null)도 테스트해야 한다.

##### Main 분리  
- 시스템 생성과 시스템 사용을 분리하는 한 가지 방법으로, 생성과 관련되 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한ㄴ다.  
- main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘긴다. 애플리케이션은 그저 객체를 사용할 뿐이다.

![Main 분리](main_separate.gif)

##### 팩토리  
- 때로는 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다.
- 예를 들어, 주문처리 시스템에서 애플리케이션은 LineItem 인스턴스를 생성해서 Order에 추가할 때 ABSTRACT FACTORY 패턴을 사용한다.
- LineItem을 생성하는 시점은 애플리케이션이 결정하지만 LineItem을 생성하는 코드는 애플리케이션이 모른다.

![팩토리](factory.png)  

## 12장 창발성  
켄트 벡이 제시한 단순한 설계 규칙 네가지가 소프트웨어 품질을 크게 높혀준다고 믿는다.  
- 모든 테스트를 실행한다.
- 중복을 없앤다.
- 프로그래머의 의도를 표현한다.
- 클래스와 메서드 수를 최소로 줄인다.

위 목록은 중요도 순이다.  

##### 모든 테스트를 실행하라  
- 테스트를 가능한 시스템을 만들면 설계 품질이 올라간다.
- SRP를 준수하는 클래스는 테스트가 훨씬 더 쉽다.
- 결합도가 높으면 테스트 케이스를 작성하기 어렵기 때문이다.

##### 리팩터링  
- 소프트웨어 설계 품질을 높이는 기법이라면 무엇이든 적용해도 괜찮다.
- 코드를 정리하면서 시스템이 깨질까 걱정할 필요가 없다. 테스트 케이스가 있으니까.

##### 중복을 없애라
```
int size() {}
boolean isEmpty() {}
```
처럼 메서드를 따로 구현했지만 따로 중복해서 구현하지 않는 방법도 있다.  
```
boolean isEmpty() {
    return 0 == size();
}
```

##### 표현하라  
- 내 코드는 나만 보는게 아니기 때문에 유지 보수하기 좋게 만들어야 한다.
- 좋은 이름을 선택한다.
- 함수와 클래스 크기를 가능한 줄인다.
- 표준 명칭을 사용한다. 디자인 패턴은 의사소통과 표현력 강화가 주요 목적이다. 표준 패턴을 사용한다면 클래스 이름에 패턴 이름을 넣어준다. 그러면 다른 개발자가 클래스 설계 의도를 파악하기 쉽다.
- 단위 테스트 케이스를 꼼꼼히 작성한다.
- 그리고 코드를 읽기 쉽게 만들기 위해 고민하라.

##### 클래스와 메서드 수를 최소로 줄여라  
- 당연한 이야기.

## 13장 동시성
> 객체는 처리의 추상화다. 스레드는 일정의 추상화다.
> \- James O. Coplien

- 동시성은 결합을 없애는 전략이다. 즉, 무엇과 언제를 분리하는 전략이다.
- 스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접하다.
- 무엇과 언제를 분리하면 애플리케이셔 구조와 효율이 극적으로 나아진다.
- 구조적인 관점에서 프로그램은 거대한 루프 하나가 아니라 작은 협력 프로그램 여럿으로 보인다.
- 그 예로 '서블릿' 이 있다. 동시성을 WAS가 관리해주기 때문에 프로그래머는 들어오는 모든 웹 요청을 관리할 필요가 없다.

##### 동시성과 관련된 타당한 생각 몇 가지  
- 동시성은 다소 부하를 유발한다.
- 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다.
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

thread race condition이 발생할 수 있다. 두 스레드가 자바 코드 한 줄을 거쳐가는 경로는 수없이 많은데, 그 중에서 일부 경로가 잘못된 결과를 내놓기 때문이다.  

#### 동시성 방어 원칙
##### SRP
- 동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하다.
- 동시성과 관련없는 코드에 동시성을 구현하지 말고 분리해라.

##### 따름 정리(corollary) : 자료 범위를 제한하라  
- race condition을 막기 위해 코드 내 **임계영역** 을 `synchronized` 키워드로 보호하라고 권장한다.
- **임계영역** 의 수를 줄이는 것 또한 중요하다.
- 공유 자료를 캡슐화하여 공유되는 자료를 최대한 줄여라.

##### 따름 정리 : 자료 사본을 사용하라  
- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다.
- 어떤 경우는 객체를 복사해 읽기 전용으로 사용하는 방법이 가능하다.
- 어떤 경우는 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법도 가능하다.
- 복사 비용하는 시간과 부하가 걱정할 수도 있지만, 사본으로 동기화를 피할 수 있다면 내부 잠금을 없애 절약한 수행 시간이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다.

##### 따름 정리 : 스레드는 가능한 독립적으로 구현하라  
- 자신만의 세상에 존재하는 스레드를 구현한다.
- 즉, 다른 스레드아 자료를 공유하지 않는다.
- 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다.
- HttpServlet 클래스에서 파생한 클래스는 모든 정보를 doGet과 doPost 매개변수로 받는다. 그래서 각 서블릿은 마치 자신의 독자적인 시스템에서 동작하는 것처럼 요청을 처리한다.

##### 라이브러리를 이해하라  
- 자바 5는 동시성 측면에서 이전 보다 많이 나아졌다.
- 스레드 환경에 안전한 컬렉션을 제공한다. 자바 5부터
- 서로 무관한 작업을 수행할 때는 executor 프레임워크를 사용한다.
- 가능하다면 스레드가 차단 되지 않는 방법을 이용한다.
- 일부 클래스 라이브러리는 스레드에 안전하지 못하다.
- `java.util.concurrent` 패키지의 `ConcurrentHashMap` 가 스레드 환경에 안전한 컬렉션 중 하나다.

##### 실행 모델을 이해하라  
- 한정된 자원 : 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예다.
- 상호 배제 : 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.
- 기아 : 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다.
- 데드락 : 여러 스레드가 서로가 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.
- 라이브락 : 락을 거는 단계에서 각 스레드가 서로를 방해한다. 스레드는 계속해서 진행하려 하지만, 공명으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한
다.

#### 다중 스레드 프로그래밍에서 사용하는 실행 모델

##### 생산자-소비자  
- 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣는다.
- 생산자/소비자 스레드가 사용하는 대기열은 한정된 자원이다.
- 생산자 스레드는 대기열에 빈 공간이 있어야 넣는다.
- 소비자 스레드는 대기열에 정보가 있어야 가져온다.
- 대기열에 빈 공간이 있고, 정보가 있다는 신호를 서로 보낸다.
- 그럼 진행 가능한 상황에도 동시에 서로에게서 시그널을 기다릴 가능성이 존재한다.

##### 읽기-쓰기  
- 읽기 쓰레드의 요구와 쓰기 쓰레드의 요구를 적절히 만족시켜서 처리율도 적당히 높이고 기아도 방지하는 해법이 필요하다.
- 간단한 전략은 읽기 쓰레드가 없을 때까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법이다.

##### 식사하는 철학자들  
- 데드락을 설명하기 위한 문제
- [나무위키 링크](https://namu.wiki/w/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94%20%EC%B2%A0%ED%95%99%EC%9E%90%20%EB%AC%B8%EC%A0%9C)

##### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라  
- 공유 클래스 하나에 동기화된 메서드가 여럿이라면 구현이 올바른지 확인하라.
- 동기화된 메서드가 여러개가 필요한 상황이 생길수도 있다. 다음과 같이 처리한다.
- 클라이언트에서 잠금 : 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다.
- 서버에서 잠금 : 서버에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제" 하는 메서드를 구현한다. 클라이언트는 이 메서드 호출.
- 연결(Adapter) 서버 : 잠금을 수행하는 중간 단계를 생성한다. '서버에서 잠금' 방식과 유사하지만 원래 서버는 변경하지 않는다.

## 17장 냄새와 휴리스틱  
모르는 것만 정리했다.  

#### 주석  
##### 성의 없는 주석  

#### 함수  
##### 출력 인수
- 일반적으로 독자는 인수를 입력으로 간주한다. 함수에서 뭔가의 상태를 변경해야 한다면 함수가 속한 객체의 상태를 변경한다.

#### 일반  
##### 한 소스 파일에 여러 언어를 사용한다.
##### 당연한 동작을 구현하지 않는다.
- 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다.
##### 추상화 수준이 올바르지 못하다.
- 고차원은 추상 클래스에서.
- 저차원은 파생 클래스에서.
##### 기초 클래스가 파생 클래스에 의존한다.
- 클래스른 나누는 이유는 고차원 클래스 개념을 저차원 파생 클래스 개념으로 나누어 독립성을 보장하기 위함이다.
- 기초 클래스가 파생 클래스를 사용한다면 뭔가 문제가 있다는 말이다.
##### 선택자 인수  
- 함수 호출 끝에 달리는 false 인수만큼이나 밉살스런 코드도 없다.
- 선택자 인수는 목적을 기억하기 어려울 뿐 아니라 각 선택자 인수가 여러 함수를 하나로 조합한다.
- 차라리 새로운 함수를 만들어라.

##### 조건을 캡슐화하라  
##### 부정 조건은 피하라  

#### 자바  
##### 긴 import 목록을 피하고 와일드카드를 사용하라  
`import pakage.*`

##### 상수는 상속하지 않는다.  
