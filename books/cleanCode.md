# 클린 코드  
## 목차  

* [2장 의미있는 이름](#2장-의미있는-이름)
* [3장 함수](#3장-함수)  
* [4장 주석](#4장-주석)
* [5장 형식 맞추기](#5장-형식-맞추기)
* [6장 객체와 자료구조](#6장-객체와-자료구조)
* [7장 오류 처리](#7장-오류-처리)

## 2장 의미있는 이름  
##### 의도를 분명하게 밝혀라  
```
int daySinceCreation;
int elapsedTimeInDay;
int fileAgeInday;
```  

`str1, str2` 대신 `source, destination`을 쓰면 가독성 up

##### 검색하기 쉬운 이름을 써라  
- 통상적으로 이름이 길어질수록 검색하기 쉽다.

##### 인코딩을 피하라  
- 헝가리안 표기법처럼 타입을 변수명에 넣을 필요가 없다.
- 멤버 변수 접두어 넣을 필요 없다. `m_name`
- 인터페이스와 구현 클래스는 `IShapeFactory` 처럼 인터페이스에 표시해주기 보다는 구현 클래스에 `ShapeFactoryImpl` 이라고 나타내는게 낫다.

##### 클래스나 객체 이름  
- 클래스나 객체 이름은 명사나 명사구
- Manager, Processor, Data, Info 등과 같은 단어는 피한다.

##### 메서드 이름  
- 메서드 이름은 동사나 동사구
- set, get, is는 javabean 표준에 따라서 붙인다.
- 생성자를 중복정의 할 때는 정적 팩토리 메서드 이용
```
Complex fulcrumPoint = Complex.FromRealNumber(23.0);
Complex fulcrumPoint = new Complex(23.0);
```
아래 코드보다 위 코드가 좋다.

##### 일관성있는 어휘 사용  
- fetch, retrieve, get을 섞어쓰면? 복잡하지

##### 말장난을 하지 마라  
- add는 둘을 더하는거고, A에 B를 넣는것은 insert나 append라는 이름을 쓰자.

## 3장 함수  
##### 작게 만들어라!  
- if/else/while 등에 들어가는 블록은 한 줄이여야 한다.

##### 함수 당 추상화 수준은 하나로  
- 같은 함수 내에서 추상화 수준이 뒤죽박죽 섞이면 파악하는데 헷갈림

##### Switch case?  
- switch 문은 추상 팩토리 클래스를 구현해서 그 안에 숨긴다.

##### flag 인수는 추하다?  
- 메서드 안에서 이것저것 많이 한다고 공표하는 셈이라 추하다?

##### 부수 효과를 일으키지 마라?  
- 함수에서 한 가지를 하겠다고 명시했는데 그 안에 다른 처리도 끼어들어가 있는 것.

##### 출력 인수  
- 일반적으로 출력 인수는 피해야 한다. 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택한다.  
```
appendFooter(s);
public void appendFooter(StringBuffer report);
```
위 코드만 보고 s가 무엇인지 위해서 함수 선언부를 찾아보게 된다.
그러므로 아래 코드처럼 바꾸는게 좋다.  
```
report.appendFooter();
```

##### trycatch  
- try/catch 블록은 별도 함수로 뽑아내는 편이 좋다.
- 정상 동작과 오류처리 동작을 분리한다.


## 4장 주석  
##### 주석은 나쁜 코드를 보완하지 못한다.  
- 그 시간에 코드를 다시 고치는게 낫다.

##### 좋은 주석  
- 코드에 표현할 수 없는 부분만 쓰는게 낫다.
- 또는 결과를 경고하거나 중요성을 강조하는데 쓰인다.
- 법적인 내용을 담고 있는 주석.

##### 나쁜 주석  
- 같은 이야기를 반복하거나 주석이 또 다른 의문을 들게한다.
- 오해할 여지를 남긴다.

## 5장 형식 맞추기  
##### 수직 거리  
- 서로 밀접한 개념은 세로로 가까이 둬야한다.
- 서로 멀리 떨어져있으면 소스를 위아래로 뒤지게 되니까.

##### 변수 선언  
- 변수는 사용하는 위치에 최대한 가까이 선언한다.
- 인스턴스 변수는 클래스 맨 처음에 선언한다. 변수 간 세로로 거리를 두지 않는다.

##### 함수 선언  
- 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.
- 되도록 호출하는 함수를 호출되는 함수보다 먼저 배치한다.

## 6장 객체와 자료구조  
##### 자료 추상화  
- 변수에 대한 단순한 get,set은 구현을 노출시킬 뿐이다.(직교 좌표계, 극 좌표계)
- 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스이다.
##### 자료/객체 비대칭  
- 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 제공.
- 자료구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않음.
- 객체와 자료구조는 근본적으로 양분된다.
- 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 모든 함수를 고쳐야 한다.
- 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.
##### 디미터 법칙  
- 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙.
- 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다, 고 주장한다.
- 클래스 C
- f가 생성한 객체
- f 인수로 넘어온 객체
- C 인스턴스 변수에 저장된 객체
- 낮선 사람은 경계하고 친구랑만 놀라는 의미
```
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```
같은 코드를 쓰지 말라는 것. 이를 기차 충돌(train wreck) 이라고 부른다.  
다음과 같이 코드를 나누는 편이 좋다.  
```
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```

## 7장 오류 처리  
##### 오류 코드보다 예외를 사용하라  
- 오류가 발생하면 예외를 던지는 편이 호출자 코드가 깔끔해진다.

##### 호출자를 고려해 예외 클래스를 작성하라  
- 오류 분류를 잘만 해놓아도 깔끔하게 예외 처리가 가능
- wrapper 클래스를 이용해서 관련 예외를 하나로 처리
```
//wrapper 클래스
LocalPort port = new LocalPort(12);
try {
  port.open();
} catch {
  //blah...
}
```

##### null을 반환하지 마라  
- null을 반환하는 것은 일거리를 늘릴 뿐 아니라 호출자에게 문제를 떠넘긴다.
- null을 반환하면 꼭 null 체크를 해줘야한다.
- 예외를 던지거나 특수 사례 개체 ex)`return Collections.emptyList()`를 반환하는 것이 좋다.

##### null을 전달하지 마라  
- null인 가능성이 있는 객체를 전달하기 이전에 null 체크가 필요하다.
