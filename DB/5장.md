# 5장 가용성과 데이터의 복제

## 5.1 데이터베이스는 어떤 때에 크래쉬되는가?  

### 전형적인 장애 시나리오  

- 소프트웨어 장애
- OS 장애
- 하드웨어 장애
- 조작 실수

### 디스크 이중화로 데이터 손실 방지하기  

장애가 발생할 확률을 줄이는 것은 좋으나, 장애를 100% 막을 수는 없기 때문에 '장애가 발생해도 서비스를 제공할 수 있도록 설계하는 것' 이 중요하다.  

장애 대책 중에서도 특히 중요한 것이 '데이터 손실 방지' 이다.  

#### RAID  

데이터베이스의 데이터는 HDD에 저장되는데 (옛날기준), HDD의 고장률이 높기 때문에 여러 개의 HDD를 탑재하고 동일한 데이터를 두 개 이상의 HDD에 분산 저장하는 기술이다.  
저장 방식에 따라서 RAID0 ~ RAID6 까지 다양한 방식이 있다. RAID 구성에 따라 다르지만 한 개가 망가진 상태에서 방치하면 성능 손실이 있고, 두 번째가 망가지면 데이터 손실의 위험이 있다. 그래서 첫 번째가 손실된 경우 서비스를 멈추지 않고 망가진 HDD를 교체하는 '핫 스왑' 이라는 기술이 병용된다.  

이슈가 되는 것은 HDD 뿐 아니라 CPU, 커널 패닉, DB 프로세스 장애 등 다양한 상황이 있다. 그래서 RAID 구성이 되어 있더라도 서버가 하나 뿐이라면, 시스템은 즉시 다운된다. 그래서 서버가 여러대가 필요하다.

## 5.2 복제  

복제를 할 때 고려되는 trade-off는 성능과 무결성이다.  

### 단방향 복제  

#### 단방향 비동기  

마스터에서 갱신한 결과가 슬레이브에 비동기로 전파되는 유형의 복제이다.  
마스터에서 실행한 SQL이 **바이너리 로그**라는 전용 로그로 저장됨. 이 로그 파일의 내용이 슬레이브로 전송되어 저장되고, 슬레이브는 이 저장된 로그 파일을 순차적으로 실행하면서 마스터와 싱크를 맞춰간다.  
슬레이브는 바이너리 로그 **수신** 과 **실행** 두 단계로 싱크를 맞춘다. 수신은 IO스레드, 실행은 SQL 스레드가 실행한다. 모두 비동기로 동작하는데, 네트워크 병목보다는 디스크 병목이 성능상 이슈가 많이 발생한다. 수신은 네트워크를 통해서 수행되기 때문에 거의 동기 같은 속도로 진행된다. 하지만 실행은 디스크에 접근하기 때문에, 디스크에서 병목이 생기면 지연이 발생하게 된다.  

마스터에서 장애가 발생한 경우, 슬레이브와 싱크가 완전히 맞춰지지 않는 경우가 생길 수 있다.  

1. 마스터에서 생성한 바이너리 로그가 슬레이브에서는 마지막까지 수신되지 않은 상황
2. 슬레이브에서의 바이너리 로그의 실행이 마지막까지 종료되지 않은 상황  

1의 경우는 마스터가 변경 내용을 다 보내지 못하고 죽은 경우, 데이터가 유실 될 수 있다. MySQL만 죽고 서버는 살아있는 경우 SSH 접속을 통해서 바이너리 로그를 가져오는 구제 조지도 가능은 하다.  
2의 경우는 슬레이브에서 실행을 담당하는 SQL 스레드가 지연되었기 때문이다. 마스터가 주는 변경 사항만 잘 받았다면, 마스터가 죽었더라도 시간이 지나면서 불일치가 해소될 수 있다. 이때, 마스터가 죽었다고 아직 싱크중인 슬레이브를 마스터로 승격하여 새로운 변경 사항을 업데이트하려고 할 수 있다. 제대로 복구를 하려면 슬레이브가 죽은 마스터의 바이너리 로그와 싱크를 맞춘 후에 새로운 업데이트 트래픽을 옮겨 줄 필요가 있다. 이것도 자동으로 해줌  

#### 단방향/준동기화  

마스터의 바이너리 로그를 수신하지 못했는데 마스터가 죽으면 데이터가 유실되기 때문에, 수신 과정만 동기식으로 처리하는 것이다. 대신 슬레이브가 수신을 받고나서 응답을 줄 때까지 기다려야 하기 때문에 비동기 방식에 비해서 성능이 저하될 수 있다.  

#### 단방향/동기  

수신과 실행 모두 동기식으로 처리하는 것이다. 마스터가 죽고나면 바로 슬레이브에서 서비스 재개가 가능하다.  

### 양방향 복제(멀티 마스터)  

위에서 소개한 양방향 복제는 마스터 -> 슬레이브는 단방향이라는 제약이 있기 때문에 업데이트는 마스터에서만 할 수 있다. 또한 슬레이브는 단일 스레드로 복제를 담당하게 되어 있으므로 갱신의 동시성이 없다. (?)  
하드웨어가 발전하면서 병렬 처리가 가능해졌기 때문에, 이를 이용해서 여러 개의 마스터를 두고 각각 업데이트 하는 것을 말한다.  

#### 기술적 어려움  

멀티 스레드로 업데이트를 시도하면 race condition이 발생하게 된다. 그렇기 때문에 분산형 배타 제어의 구조가 필요하다. 근데 MySQL 처럼 비동기/준동기 복제를 기반으로 한 제품에서는 배타 제어가 어렵다. 그래서 마스터가 여러 대여도, 동일한 key에 대해서는 한 서버에서만 update를 할 수 있도록 어플리케이션에서 로직을 제어해주는 것이 필요하다.  

DB 제품에 따라서는 여러 서버에 업데이트를 할 수 있고 자동으로 동기화를 해주는 것이 있다. MySQL Cluster도 그 중 하나인데, 데이터 노드라는 특수 서버에서 데이터를 보관한다. 이 데이터 노드는 replication 되고, 변경이 발생하면 다른 노드에 동기적으로 반영된다.  

또한 MySQL Cluster에서는 동기 복제를 구현하고 있어서 A노드 -> B노드로 업데이트 하는 동안 동일한 Key를 B에서 업데이트 할 수 없도록 lock을 잡는다. 양방향/비동기 복제에서 어플리케이션 로직으로 배타 제어 해야 하는 것을 DB에서 해주는 게 장점이다.

### 장애로부터의 복구 방법  

슬레이브가 죽은 경우는, 다른 슬레이브나 마스터에서 데이터를 받아 복원하거나, 정기 백업을 이용한다.  

OS 장애로 일시적으로 다운되었으나, 데이터 자체는 디스크에 남아 있는 장애도 있다. 이 경우 다시 서비스를 시작하면 복제를 재개해 줄 것이라고 생각하지만 쉽지 않은 문제이다.  
MySQL에서는 '복제가 어디까지 진행되고 있었는가?' 라는 상태 정보를 파일로 관리하고 있다. 하지만 디스크에 쓴 내용과, 이 상태 정보 파일 간 싱크가 맞지 않을 수도 있다. 그래서 OS 장애 등 크래쉬가 일어나면 '실제로 업데이트 된 위치' 와 '정보 파일에 기록되는 위치' 가 어긋날 수도 있다.  

그래서 대부분의 현장에서는 죽은건 그냥 버리고 정상인 것에서 통째로 받아와서 새로 만든는 방법을 취하고 있으나, 데이터 양이 크면 그것대로 문제가 된다. 그리고 데이터를 넘겨주는 정상 마스터/슬레이브도 모든 리소스와 대역을 새로운 슬레이브 만드는데만 쓸 수 없으니 이 부분도 고려해야 한다.  

그래서 장애 시점과 현 시점의 차이만을 (diff) 찾아서 복구하는 방법이 주류를 이루게 될 것이다. (과연 현재는 ?)  

### 인위적 실수에 대한 해결  

사람의 실수는 막기 어렵기 때문에 주기적 백업을 하라고 나와있으나, 그것도 중요하지만 나는 권한 관리가 더 중요하다고 생각  

### 백업을 복원한 후 어떻게 하면 좋은가?  

백업을 해두는 것은 좋으나, 백업 자체도 꽤 무거운 작업이어서 보통 트래픽이 적은 새벽 시간대에 수행하게 된다. 하루에 한 번 백업을 하게 되면 DB 다운 시, 최대 만 하루 분량의 데이터 손실이 발생하게 된다. 그래서 나온 기술이 '시점 복구(Point In Time Recovery, PITR) 이다.  

MySQL에서는 UPDATE 문 등에 의한 경과가 바이너리 로그(업에데이트 로그)에 기록되고 있다. 그래서 마지막 백업 이후의 업데이트 로그가 성공적이면, 백업으로 복구한 후에 업데이트 로그를 사용하여 장애 이전 상태로 복구 할 수 있다.  

하지만 업데이트 로그에서도 백업 이후 부분만 찾아서 반영해야하기 때문에 이 지점을 찾을 필요가 있다. 가장 쉬운 방법은 '일시적으로 업데이트를 멈추고 백업을 하여 그 시점에서의 업데이트 로그의 위치를 특정하는' 방법이 있다. 하지만 백업할게 많으면, 장시간 업데이트가 막히게 된다. 이런 문제 때문에 트랜잭션 구조를 응용하여 업데이트를 멈추지 않고 백업하는 '온라인 백업' 기능을 제공하는 RDBMS가 있다.  

### 고의로 지연시킨 복제  

사람의 실수를 막기 위해서 복제를 실시간으로 하지 않고, 고의로 1시간을 지연시키는 것이다. 사고가 발생하면, 실수한 서버를 내리고, 지연 동기화 되고 있던 다른 서버를 마스터로 세우는 것이다. 하지만 좋은 방법인지는 모르겠다.  
