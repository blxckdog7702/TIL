# 7장 스토리지 기술의 변천과 데이터베이스에 끼치는 영향  

## 7.1 하드웨어 성능 개선의 역사  

### HDD에 의한 처리의 한계  

인덱스와 실제 데이터는 물리적으로 인접해 있지 않기 때문에 각각 별도로 액세스할 필요가 있다. 이를 **랜덤 엑세스**라고 한다.  
기본 키 검색에 의한 한 개의 레코드 검색이라 할지라도 인덱스와 실제 데이터에 대한 두 번의 랜덤 액세스가 필요하다. DB가 동일 시간 내 처리할 수 있는 랜덤 액세스 수는 정해져 있기 때문에 이에 따라서 DB의 처리량이 정해진다.  
DB에 따라서 초당 수천에서 수십만까지 성능 차이가 나는 경우가 있는데 그건 바로 데이터가 어디에 있느냐의 차이이다. 액세스하려는 데이터가 메모리에 캐시되어 있는 경우 액세스 속도가 매우 빠르기 때문에 처리량이 높고, 디스크는 상대적으로 느리기 때문에 메모리에 비해서 처리량이 낮다.  
HDD 특성 상 디스크 헤드가 해당 트랙에 도달하기 까지 걸리는 **탐색 대기 시간**과 트랙의 데이터가 원하는 위치에 올 때까지 기다리는 회전 **대기 시간이 발생**한다. 예전에는 HDD 평균 처리 시간이 10밀리초 정도였고, 이는 1초에 100번 밖에 처리를 하지 못한다는 말이다.  
1초에 처리할 수 있는 I/O 횟수를 IOPS(input output per second)라고 한다. 한 개의 SQL 문을 처리하기 위해서는 여러번의 랜덤 액세스가 필요하기 때문에 HDD에 액세스하는 경우 초당 10 쿼리 정도밖에 처리할 수 없을지도 모른다.  

### 메모리 가격 하락에 따른 64비트 환경의 극대화  

#### 메모리 상에서의 작업 수행  

속도가 느리면 DB에는 치명적이기 때문에 데이터 파일 중에서도 자주 사용되는 영역을 메모리에 캐시해 두어 빠른 액세스가 완결될 수 있도록 해야한다. 이런 구조는 DB 뿐 아니라 OS에서도 동일하게 채용하고 있다.  
예전엔 메모리 양이 작았지만, 점점 메모리가 저렴해지고 이용할 수 있는 메모리 용량이 커지면서 캐시 가능한 데이터 양도 계속해서 증가하는 추세이다. 캐시의 크기보다 데이터 양이 크면 클수록 HDD에 직접 접근하는 횟수는 늘어나고, 그러면 처리 성능이 느려지게 될 것이다.  
RAID 구성을 만들고 병렬성을 올렸다 해도 성능이 쉽게 늘어나진 않는다. 그리고 처리의 대부분이 조회라면 슬레이브를 다수 놓으면 되지만, 업데이트가 많으면 업데이트 작업이 마스터와 슬레이브 양쪽에서 이루어지기 때문에 이마저도 해결이 되지 않는다. 그래서 예전에는 샤딩을 통해서 요청을 분산해서 처리하곤 했다.  

#### 64비트 시대의 메모리 탑재량 ㅋㅋㅋㅋㅋ  

64비트 운영체제가 나오면서 사용할 수 있는 메모리 양은 더욱 커졌다. 예전에 비해서 메모리(캐시)를 키울 수 있게 되었다. 그러면 기존에 캐시가 작은 여러 대의 서버로 처리했던 일들을 한 대의 큰 캐시를 가진 서버로 대체해서 처리할 수 있게 된다. 이러면 한 대가 받는 요청은 더 많아졌으므로 병렬성에 신경써야하고, 메모리 이용 효율이 높은 다이렉트 I/O를 사용하게 되었다.  

> 다이렉트 I/O : 디스크 I/O시 커널의 버퍼를 건너 뛰고 유저 영역에 직접 I/O 하는 방식  

#### 단일 스레드 처리의 성능 문제  

가용 메모리가 커지면서 1대의 DB 서버가 처리할 수 있는 양도 늘어난다고 위에서 말했다. 하지만 메모리를 10배로 늘린다고 처리량도 10배로 늘어나는게 아닌데 그 이유는 병렬화 때문이다. 왜냐하면 집계 처리 같은 경우엔 단일 스레드로 동작하는 task는 오래 걸리기도 하고, 전체 테이블을 한 번만 액세스하기 때문에 캐시 효율도 높지 않다.  
MySQL에서 복제 구성을 할 때도 단일 스레드로 동작했다. 그래서 업데이트가 들어오면 마스터 내부적으로는 병렬 처리를 하나, 여러 대의 슬레이브에 동기화를 할 때는 단일 스레드로 동작하기 때문에 복제 지연이 발생하게 되었다.  

#### SATA SSD에 의한 성능 개선  

단일 스레드 처리 성능 이슈의 가장 큰 원인은 디스크 I/O가 느리기 때문이다. 물론 RAID를 구성해서 디스크를 여러대로 늘리거나, **명령 대기**라는 기술을 사용해서 속도 향상을 노릴 수 있다. 하지만 가장 근본적인 해결책으로는 SSD로 교체가 있다.  
SSD는 기억 장치로 플래시 메모리를 사용해서 액세스가 HDD에 비해서 매우 빠르다. 특히 SATA SSD는 랜덤 읽기 성능이 좋고, 병렬성도 높다. 단일 스레드에서 성능이 매우 높기 때문에 병목을 유발하던 단일 스레드 처리도 크게 단축 시킬 수 있다. (왜 특히 단일 스레드에서 성능이 좋은걸까?)  
그래서 책에서는 마스터는 RAID 구성의 HDD를 사용하여 다중 스레드로 병렬 액세스하고, 슬레이브는 SATA SSD를 사용하여 단일 스레드에서도 충분한 성능이 나오도록 구성하는 것이 best case 라고 한다. (다 SSD로 때려박으면..?)  

#### PCI-Express SSD의 효과  

스토리지의 인터페이스로는 SATA가 잘 알려져이씨만, PCIe도 SATA 보다 빠른 인터페이스로 좋은 고려 대상이 된다고 한다. 책에서는 이 성능 좋은 SSD를 최대한 효율적으로 사용하기 위해서 (뽕뽑) PCIe SSD 위에 여러 DB 인스턴스를 띄우는 방법도 이야기하고 있다. 그렇지만 결국 단일 스레드 동작 방식으로 문제가 되었던 슬레이브 복제 같은 task가 병렬로 개선되는게 더 중요하다.  

## 7.2 데이터베이스 개선의 역사  

하드웨어가 발전하듯이 DB 소프트웨어도 발전을 했다. MySQL에서는 다음과 같은 관점에서 개선이 이루어져 왔다.  

- CPU 확장성 향상
- 디스크 I/O 병렬성의 개선
- 백그라운드의 분할/병렬화  

MySQL 5.1 부터는 병렬성이 크게 개선되었다고 한다.  

### CPU 확장성 향상  

배타 제어를 할 때 임계 영역(critical section)을 정해서 처리해야 하는 구간이 생긴다. 이 구간은 멀티 코어여도 동시에 하나의 코어만 접근할 수 있다. 이 구간에 대한 액세스 빈도가 높을수록 멀티 코어를 잘 활용하지 못하는 소프트웨어가 되는 것이다.  
MySQL은 C/C++ 언어로 제작되어 mutex를 이용한 배타제어를 하고 있다. 그래서 이 mutext 영향이 최소화 되는 방향으로 개선이 이루어지고 있다. 예를 들어, 기존에는 데이터 캐시 영역 (버퍼 풀)에 하나 밖에 없던 mutex를 각각 16KB 블록으로 분할하여 각 블록에는 병렬 액세스가 가능하도록 개선한 것이다.  

### 디스크 I/O 병렬성의 개선  

HDD를 RAID로 구성하면 디스크가 여러개가 되어 병렬성이 증가하는 것처럼, SSD는 드라이브가 하나라도 내부적으로는 여러 개의 플래시 메모리로 구성되어 있어 높은 동시성을 발휘할 수 있는 것이 많다. 하지만, 스토리지가 여러 개가 되더라도, DB 구현도 이를 이용할 수 있는 방향으로 변화해야 한다.  
MySQL 5.1 부터는 I/O 담당 스레드 수를 설정을 통해 여러 개로 늘릴 수 있게 되었다.  

### 백그라운드 처리의 분할/병렬화  

DB에는 app에게 받은 쿼리를 처리하는 것 이외에도 백그라운드에서 실행해야 하는 작업이 몇 가지 존재한다. 그 중 대표적인 것이 체크 포인트 처리 및 DELETE 레코드를 물리적으로 제거하는 것이 있다. 이런 task 들도 쌓이면 app의 작업을 블록해야 될 수도 있어서 다중화하고 고속화하는 것이 필요하다.  
MySQL 5.5 부터는 백그라운드 처리를 여러 스레드에서 담당하게 변경되었고, 비동기 I/O도 지원하여 스레드 수가 적어도 더 많은 I/O 요청을 던질 수 있게 되었다. 근데 아직 복제의 병렬화가 되지 않아서 이걸 해결하는게 제일 중요하다고 책에서는 말하고 있다.  

> MySQL multithreaded replication은 MySQL 5.6 버전부터 지원한다고 한다.  

## 7.3 향후 데이터베이스에 요구되는 것  

### 네트워크 및 CPU 이용 효율이 더 중요하게 된다  

지금까지는 DB의 병목 현상이 거의 디스크 문제였지만, SSD가 나오면서 네트워크나 CPU 쪽으로 이동할 것이라고 한다. 예전에는 Linux 커널에서 네트워크 송수신을 하나의 CPU에서만 담당하도록 했어서 문제가 된 적도 있었지만, 지금은 여러 CPU 코어를 네트워크 송수신에 사용하도록 변경되었다.  
CPU 문제도 있다는데 디스크 I/O가 발생하지 않아도 내부적으로 문자열 처리를 한다거나, 커넥션을 맺는다던가 하는 처리에서 CPU 효율이 문제가 될 수 있다고 한다.  
하지만 전반적으로 동의하지 않는다.  
NoSQL은 CPU 이용 효율의 문제를 해결하는 것이 큰 목적 중 하나라고 한다.  

### 성능 이외의 중요성이 높아진다  

디스크 성능이 좋아지면서 DB 성능이 획기적으로 증가하였다. 이에 따라서 성능에만 신경썼던 기존과는 달리, 다양한 부분의 중요성이 대두되고 있다. 여러 기능, 복원력, 자동화 등등이다. 개발 효율과 운영 효율을 높이는 기능들에 대한 요구가 커지고 있다. 예를 들면, 마스터에 오류가 발생하면 자동으로 fail over 해주거나, scale in/out 시 데이터가 자동으로 분산되는 것 등이 있다.  
