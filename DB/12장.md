# 12장 빅 데이터 시대의 데이터베이스 설계  

## 12.1 웹 서비스를 위한 데이터베이스 개론  

### 데이터베이스의 선정 기준  

예전에는 RDBMS 만이 옵션이었다면 요즘은 NoSQL도 훌륭한 옵션이 될 수 있다. 다만 명확한 선정 기준을 가지고 데이터베이스를 선정해야 한다.  
그러면 어떤 기준을 가지고 어떤 데이터베이스를 선정하는 것이 좋을까?  

### 소셜 게임의 주요 특징  

소셜 게임을 예로 주요 특징을 소개하고, 그것을 기준으로 데이터베이스에서 어떤 기준이 요구되는지 알아보자  

#### 사용자 수가 기본적으로 많고 단번에 대폭 늘어날 수도 있다  

사용자 수가 많으면 당연히 생성되는 데이터 양이 방대해진다. 이런 계획적인 트래픽의 급증은 어느 정도 미리 준비할 수 있는 여유가 있을 것 이므로 현재의 부하를 제대로 분석하여 예측을 세우는 것이 중요하다. 특히 구체적으로는 `지금의 DB 서버의 부하 기준(데이터 양과 병렬성 및 갱신 빈도 등)이 XX이므로 이후에 N배 정도까지라면 견딜 수 있다` 라는 명확한 판단 기준을 가지고 있는 것이 중요하다.  

#### 주요 정보는 서버가 모두 가지고 있다  

게임의 모든 정보를 서버가 가지고 있다. 그렇기 때문에 서버가 해킹되면 모든 피해자가 영향을 받기 때문에 보안에 유의해야 한다. 또한 SQL 인젝션 등 프로그램 상의 문제점을 공격하기도 하지만, 내부자가 데이터를 반출하거나, 고의로 잘못된 업데이트를 할 수도 있기 때문에 권한 관리도 중요하다. 데이터베이스적 관점에서는 `어떤 데이터를 갖고 있는가` 라는 데이터베이스적인 지식과 `어떻게 안정화 및 고속화 할 것인가` 라는 인프라적인 지식이 요구된다. 또한 모든 데이터가 서버에 있기 때문에 데이터들의 행동 패턴을 분석하여 새로운 요구 사항을 도출하는 것도 가능하다.  

#### 사용자 ID를 키로 사용하는 처리가 많다  

웹 서비서는 로그인 후에 거의 모든 화면에서 사용자와 연관된 정보가 필요하다. 예를 들면 아이템이나 스킬 같은 테이블이 있다면 그런 테이블들은 모두 사용자 ID를(+a) 기본 키로 갖게 될 것이다.  

#### 구조화된 데이터 항목이 많다  

게임을 보면 사용자 ID, 아이템 ID, 소지금, 체력 등 구조화된 데이터 항목이 다수를 차지하게 된다. 데이터베이스 이론인 정규화 이론의 노하우도 충분히 활용할 수 있다.  

#### 영구적으로 필요한 데이터와 기간 한정의 데이터가 있다  

게임에는 기간 한정 데이터가 존재할 수 있다. 이런 데이터는 계속 DB 서버에 둘 필요가 없고, 불필요하게 된 시점에서 삭제하거나 백업 파일로 옮겨놓는 대응이 필요하다. 또한 세션 정보 등 매우 한정된 시간만 사용하는 정보가 있다. 이 경우는 데이터가 사라져도 큰 영향이 없기 떄문에 `memcached` 같은 캐시 서버나, fault tolerant는 지원하지 않지만(?) 속도가 비교적 빠른 NoSQL에 저장할 수 있다.  

#### 가용성과 무결성에 대한 요구가 의외로 높다  

과금 여부가 서비스의 품질을 결정한다. 장시간의 다운 타임은 과금 수익에 큰 영향을 주기 때문에 가능한 무중단으로 복구 또는 수정해야 한다. 단 트래픽이 낮은 심야 시간에 계획적인 서비스 정지를 하는 것 정도는 괜찮다.  

### 대규모 웹 서비스용 데이터베이스에 요구되는 기능  

대규모 서비스가 되면 개발 및 운영 모두에 있어서 데이터베이스 주변의 여러 문제가 보통의 방법으로는 처리될 수 없다. 서비스 특유의 요구 수준을 만족하는 데이터베이스를 사용하는 것이 중요하다. 또한 데이터베이스가 그 기능 자체를 제공하지 않더라도 지원 툴 등을 이용해서 해당 기능을 제공할 수 있다. 대규모 웹 서비스에 요구되는 대표적인 기준을 소개한다.  

#### 온라인 스키마 변경  

웹 서비스는 한번 릴리즈하면 끝나는 것이 아니라 사용자의 반응을 보면서 즉흥적으로 요구 사항을 바꾸어 나가는 성질이 있다. 그렇기 때문에 데이터 스키마를 바꾸지 못해서 요구 사항을 변경하지 못하는 경우는 없어야 할 것이다.  
약간 꼼수를 부려서 기본 키와 업데이트 시간 외에는 모든 데이터를 Text 형의 컬럼 하나에 넣는 테이블 디자인을 하는 경우도 있다. 대신 이렇게 스키마 정의가 없는(책의 표현 상) 테이블 정의는 취급하는 데이터 포맷이 통일되어 있다는 보장이 전혀 없다. 그래서 데이터를 잘 모르는 제 3자의 입장에서는 파악하기가 쉽지 않다.  
그래서 편법 쓰지 말고, 명확한 테이블 정의를 하고 싶다는 요구가 확실히 있을 때 온라인 상태에서 정의를 바꾸는 것이 중요하다 라고 책에서는 말하고 있다. MySQL에서는 복제 구성을 잘 사용하거나, 테이블 정의 변경 툴을 이용해서 거의 중단 없이 스키마 변경을 할 수 있다.  

#### 수평 분산(Sharding)의 용이성  

시스템이 커질수록 한 대의 마스터에서 모든 요청을 처리하는 것은 불가능하다. 참조 처리는 슬레이브와 캐시를 추가해서 분산시킬 수 있지만, 업데이트 프로세스는 모든 데이터베이스에 반영해야하기 때문에 참조 분산만큼 간단하지 않다.  
그래서 웹 서비스에서 많이 쓰는 방식이 샤딩이다. 데이터의 범위 별로 담당 서버를 다르게 할당하는 방식이고, 어떤 정보가 어느 서버에 속하는지 관리할 필요가 있다. 책의 설명으로는 MySQL 자체에서는 샤딩을 위한 데이터 분산 로직을 제공하고 있지 않기 때문에 이 로직은 어플리케이션에서 직접 구현해야 한다고 설명하고 있다.  
최근 MongoDB나 HBase 등 서버를 추가 인스톨하는 것만으로 자동으로 샤드 재분배를 해주는 제품도 있다.  

#### 안정성  

데이터베이스의 안정성이란 `쉽게 크래쉬되거나 데이터가 망가지지 않을 것` 과 `갑자기 원인 불명의 성능 다운으로 장시간 보류되는 일이 없을 것` 이다. 대규모 웹 서비스가 되면 데이터베이스 서버의 수가 많아져서 운영 담당자 1인당 관리할 서버 수가 많아지기 때문에 안정성이 중요하다. 시도때도 없이 이놈저놈 다 죽어나가면 사람이 관리할 수 있는 영역을 넘어설 것.  
또한 재정상의 문제로 장비는 항상 넉넉하게 준비하기가 쉽지 않다. 그런 대체 서버가 준비되지 않은 상황에서 서버가 다운되었을 경우엔 서비스 품질에 영향이 갈 것이다. 하지만 안정성은 실제로 운용해 보지 않으면 모르기 때문에 평가가 어렵다.  
가장 확실한 기준은 실적이며 이 점에서 높이 평가받은 것이 MySQL 이다. 경험적으로 데이터베이스 서버가 다운될 때 OS/하드웨어 고장이 대부분이었고, MySQL 자체의 크래쉬는 극히 일부분이었다고 한다.  

#### 단일 장애점의 제거  

단일 장애점이란 이것이 다운되면 서비스 전체가 다운되는 부분을 말한다. 데이터베이스에 있어 단일 장애점이 되기 쉬운것은 마스터다. 마스터 장애가 발생했을 때 중단 없이 자동 장애 조치를 하는 것이 중요하다. 장애 발생 시 무정지로 복구해주는 툴이 있으니 찾아보자.  

#### 두 곳 이상의 데이터 센터  

서버가 다운되는 경우가 아니라 데이터 센터 자체가 돌연사하는 경우도 생각해보아야 한다. 그래서 여러 데이터 센터에서 운용하는 것을 생각해야 한다. (Availability Zone) 당연히 데이터베이스도 거기에 대응하고 있을 필요가 있다. MySQL의 경우 표준 기능인 비동기 복제를 사용하는 것이 정석이다.  

#### 단위 성능의 차이  

동일한 트래픽을 더 적은 서버 대수로 처리할 수 있다면 당연히 비용이 낮기 때문에 좋다. 이 지표도 확인해볼 필요가 있다. 수평분할이 되어도 단위 성능이 일반 RDBMS 보다 낮은 제품도 있고, 메모리 내의 성능은 좋아도 공간 효율이 나쁘고 디스크 I/O가 빈발하는 것도 있다. 그래서 신중하게 벤치마크하는 것이 중요하다.  

#### 국소적인 초고속화  

대규모 웹 서비스에서는 극히 일부의 처리에 대해서 액세스가 매우 집중되는 경향이 있다. 예를 들어 웹 서비스는 사용자 테이블로의 액세스가 매우 높은 빈도로 발생한다. 이런 테이블들은 크기가 그렇게 크지는 않아서 전체를 메모리에 캐시할 수 있다. 그러면 메모리 안에서의 액세스 성능이 중요하게 되는데, 이것은 SQL 문에서 접근하기 보다 memcached와 같은 NoSQL 프로토콜로 접근하는 것이 빠른 것이다. 그래서 이런 용도에서는 NoSQL 쪽이 우위를 차지하고 있다.  
MySQL에서는 SQL 인터페이스 뿐 아니라 NoSQL 프로토콜에서의 액세스도 지원하는 움직임이 있다. 이는 평소 트래픽에서는 사용에 익숙한 SQL 문을 사용하고, 제한적인 초고속 용도에서는 NoSQL을 사용하는 하이브리드 구성이다. (근데 왜 요즘엔 이렇게 안쓰지?)  
사용자 ID를 키로 사용자 정보를 바로 가져오는 단순한 처리라면 NoSQL이 적합하겠지만, 실제로는 이보다 더 복잡한 처리가 더 빈번하게 이루어지는 경우가 있다. 트위터를 예로 들면, `자신이 팔로우하고 있는 사람들의 최근 20개 트윗을 표시하기` 라는 처리가 있다. 이를 처리하기 위해서는 자신이 팔로우하고 있는 사람들의 최근 트윗을 모두 꺼내 시간 순으로 정렬이 필요하다. 이건 단 한번의 SQL 문으로 구현하기는 힘들고, 여러 번의 SQL 문을 실행해야 하는데, 이로 인해 네트워크 왕복 횟수가 증가하므로 응답 시간에 영향을 미치게 된다.  
이러한 빠른 액세스를 하려면 stored procedure와 같이 데이터베이스 측면에서 완벽한 처리를 구현하는 것이 효율적이다. MySQL을 잘 다룰 수 있다면 SQL 문의 stored procedure가 아닌 내부 스토리지 엔진 API를 사용하여 매우 빠른 속도로 레코드에 직접 액세스 할 수도 있다.  

#### 규모가 다르면 선정 기준도 바뀐다  

사용자의 기호에 따라서 제품 선택이 달라지기도 하지만, 서비스 규모에 따라서도 선택 기준이 바뀐다. 10대 정도의 소규모 환경에서는 자동 샤딩을 지원하는 MongoDB나 HBase도 괜찮다. MySQL은 트래픽이 많아진 때에 서버를 추가하면 데이터의 분산 배치를 자동으로 해주는 구조를 표준으로 제공하고 있지 않다. 그래서 각 샤드에 대한 분산 로직을 직접 구현해야 한다. 근데 이를 자동으로 해주는 NoSQL을 사용하면 개발 시간이 크게 줄어든다.  
하지만 NoSQL은 대량의 데이터를 취급하는데 중요한 레인지 파티셔닝 및 Change Buffering 등의 고속화 기술과 온라인 백업 및 크래쉬 시에 데이터 손실 없이 처리하는 트랜잭션 기술 등 핵심 기능의 대부분이 누락되어 있다. 이에 비해 MySQL(innoDB)는 모두 구현되어 있다.  
한 대당 실질적인 성능과 처리할 수 있는 데이터의 크기는 이러한 고속화 메커니즘을 가지고 있는 MySQL 쪽이 높다. 단순이 MySQL 구분 분석보다 NoSQL API 접근이 빠르다고 말할 수 있지만, 큰 크래픽을 취급하는 서비스에서는 이런 사실이 관계 없는 상황이 벌어질 수 있다. 실제 환경에서는 디스크 I/O에서 병목 현상이 일어나므로 구문 해석 같은 CPU 주변 처리가 아니라 I/O 주변 처리가 최적화된 제품이 더 빠르다.  
`빠른 복구`도 중요한 요소이다. 1,000대 정도의 서버를 적은 인원으로 운영하고 있으면 뭔가 문제가 있을 때 빠르고 쉽게 복구할 수 있는 것이 중요하다.  
그리도 비용에 따라서도 달라진다. 1,000대를 800대로 줄이는 것은 중요하다고 느낄 수 있으나 10대를 8대로 줄이는 것은 그렇지 않을 수 있다. 비용에 따라서 돈을 좀 더 들이더라도 안정성 있는 제품을 선택할 수 있다. 또한, 대규모 웹 서비스에서는 총 비용이 커지기 때문에 그것을 조금이라도 줄이기 위해서 내결함성을 갖춘 MySQL을 선택하여 누락된 샤딩 등의 기능은 직접 개발하기도 한다.  
결론은 최고의 솔루션은 환경에 따라 다르다. 그래서 유행에 휩쓸리지 않고 자기자신이 이해하고 잘 다루는 것이 중요하다.  

## 12.2 Mobage에서의 데이터베이스 활용 사례  

### 대규모 서비스 및 데이터베이스  

페이지 뷰는 일 20억 ~ 30억, 서버 대수는 수천대가 있으며 DB 서버 대수도 1,000대 수준에 이른다고 한다. 아래서는 클라우드와 실제 서버 중 어느 쪽을 선택할지와, 왜 많은 데이터베이스 중 MySQL을 사용하는지에 대해서 말한다.  

### 클라우드와 실제 서버  

대규모가 되기 쉬운 애플리케이션을 가동하는데는 다음과 같은 주제가 큰 과제가 된다.  

- 예상 외의 트래픽 증가 및 감소에 대한 대처
- 성능 효율의 개선
- 장애 발생률의 감소
- 운용 체제의 정비

위 주제에 대해서 On-premise와 클라우드 간 비교를 해본다.  

#### 트래픽 증가/감소에 대한 대응  

트래픽 증가/감소에 따라서 서버를 증설/감축하는 속도는 클라우드가 실제 서버에 비해서 훨씬 빠르다. 또한 실제 서버는 구매 비용도 비싸지만, 서버를 다시 판매해야 하기 때문에 감축도 쉽지 않다.  
그리고 데이터베이스 서버는 API 서버와 달리 서버를 물리적으로 제공하는 것으로는 충분하지 않다. 데이터를 복사하여 투입 가능한 상태로 만드는 과정이 필요하다. 그리고 클라우드는 사용한 만큼 과금하기 때문에 소자본으로도 이용이 가능하다.  

#### 성능 개선  

데이터베이스의 성능은 하드웨어에 의해 크게 영향을 받는다. 성능을 충분히 발휘하기 위해서 특정 하드웨어와 OS를 사용하고 싶은 경우가 많다. PCI-Express SSD를 사용하거나 최신 Linux 커널을 사용하는 등의 요구사항이 있을 수 있다. 또한 한대의 하드웨어에 여러 개의 가상 IP 주소를 할당하고 여러 데이터베이스 인스턴스를 시작하는 것과 같이 사용할 수도 있다. 자체 서버는 이런 커스터마이징을 쉽게 할 수 있다. 책에서는 클라우드 서비스는 이런 세팅이 쉽지 않다고 했는데, 이 정도의 세팅은 가능한 것 같다.  

#### 성능 분석  

미들웨어 중에는 어느 정도 조건이 겹친 경우(특히 부하가 높은 경우) 급격하게 성능이 떨어질 때가 있다. 원인은 하드웨어, 네트워크, OS 등 여러 가지가 있다. 성숙도가 낮은 제품을 사용하면 돌발 적인 성능 다운이 발생하는 경우가 있다. 그렇기 때문에 원인을 분석하는 것이 중요하다. 자가 서버를 이용하면 모든 조작을 할 수 있기 때문에 원인을 근본적으로 알아낼 수 있다. 하지만 클라우드 환경이라면 네트워크 주변은 블랙박스이며 근본 원인까지 밝혀지지 않는 경우가 많다. 또한 장비 차원에서 전원 조작이나 RAID 재구성, OS 교체 같은 레벨의 조작이 어렵다. 또한 루트 권한을 가질 수 없기 때문에 하드, OS의 원인 분석 또한 할 수 없다.  
서비스의 규모가 커지면 장애의 범위가 서버 간으로 걸쳐서 많이 나오게 된다. 서버 간이란 네트워크 스위치 장비를 경유한 통신 등이 해당된다. 스위치 장비 설정 미비로 통신 장애가 발생하는 경우도 생긴다. 클라우드는 이 부분도 보이지 않아서 사업자에 문의를 해야한다.  
클라우드는 문제가 발생했을 때 많은 부분이 블랙박스가 되어 문제를 직접 판단하기 쉽지 않다. 이와 같은 이유로 자가 서버를 이용하는 경우도 많다.

#### 운용 체제의 정비  

클라우드 서비스를 사용하는 장점 중 하나는 운용 관리를 어느정도 대신해 준다는 점이다. RDBMS의 클라우드 서비스를 제공하고 있는 사업자 중 일부는 정기적인 백업(무중단 온라인) 및 장애 발생 시 장애 조치 등을 자동으로 해주는 곳이 있다. 또한 가동 상황을 그래프로 보여주고, 문제 발생시 알림을 보내주는 것도 있다. 이런 항목들은 관리에 꼭 필요하지만, 경험이 적은 기업/관리자라면 생각하지 못할 수도 있다. 이렇게 서비스를 세밀하게 운용해준다는 것이 클라우드의 또 다른 매력이다. 자가 서버를 운영하는 경우, 위의 것들을 직접 해야한다.  

### 데이터베이스 제품 선정  

글쓴이의 회사인 DeNA에서는 다음과 같은 이유로 MySQL을 사용하고 있다고 한다.  

- 성능이 높을 것
- 시계열/이력계 데이터의 취급에 능할 것
- 트랜잭션/무정지성 기능이 충실할 것
- 양질의 문서/품질/보급도를 충족할 것

#### 성능이 높을 것  

서비스가 대규모가 되면 서버 한 대로 서비스를 제공하는 것으은 무리이다. 그래서 서버를 순차적으로 추가 투입함으로써 해결할 수 있는 처리량을 높일 수 있도록 설계하는 것이 일반적이다. 이러한 설계를 확장(scale out)/수평 분할이라고 한다.  
확장은 클래식한 구조이기도 하지만, DB 서버를 무작정 추가하면 비용이 많이 소요된다. 서버 대수가 많아질수록 운영 포인트가 늘어나고 운영 비용이 증가하기 때문이다. 그래서 적당한 성능의 서버를 관리 가능한 대수로 구성하는 것이 중요하다. 그리고 한 대로 구성할 수 이쓰면 RDBMS만의 혜택을 받을 수 있다. 예를 들어 조인, 아토믹 갱신, 외부 키 제약 등은 모두 유용한 기능인데, 여러 대의 DB 서버에 걸쳐서는 제공할 수 없기 때문이다. 이런 기능들을 어플리케이션에서 구현해서 제공하는 것은 매우 어렵다.  

#### 시계열/이력계 데이터의 취급에 능할 것  

대다수 웹 서비스에서는 어느 정도 정해진 기간 동안 데이터를 유지할 필요가 있다. 하지만 시계열 데이터는 액세스 범위에 극단적인 편향을 보여준다. 그래서 액세스가 많은 새 데이터는 데이터 양에 관계 없이 항상 좋은 성능을 제공하는 것이 중요하다. 이때 포인트는 인덱스의 구조적 특징이다. 인덱스가 커질 수록 업데이트 성능은 줄어든다. 이때 인덱스의 크기를 일정 이하로 유지해서 업데이트 성능을 유지하는 기술이 `레인지 파티셔닝` 이다.  
MySQL의 레인지 파티셔닝 기능을 사용하면 하나의 테이블을 물리적으로 여러 파티션으로 나눌 수 있다. 인덱스는 파티션 단위로 만들어지기 때문에 테이블이 거대하게 되어도 개발 인덱스 크기는 일정 이하로 유지할 수 있다.  
테이블 자체를 복수로 분리하는 것도 비슷한 효과를 얻을 수 있지만 테이블 이름이 바귀면 그것을 참조하는 어플리케이션 로직이 영향을 받기 때문에 로직이 복잡해지게 된다.  
대량 데이터라면 NoSQL로 분산 데이터베이스를 구축하면 된다고 생각하는 사람도 있으나, NoSQL은 레인지 파티셔닝 기능이 없기 때문에 한 대당 탑재할 수 있는 데이터 양이 MySQL에 비해서 훨씬 작게 된다. 그래서 MySQL 보다도 많은 서버가 필요하게 되어서 비용 효과가 떨어진다.  

#### 트랜잭션/무정지성 기능이 충실할 것  

다른 서버 간의 트랜잭션은 엄격하게는 보장되지 않지만, 애플리케이션 프레임워크 등을 이용하여 여러 서버로의 커밋/롤백을 한 번에 할 수 있도록 설정하고 이와 더불어 중간에 실패하는 경우에는 나머지 서버로의 롤백을 실행하면 십중팔구 일관성은 유지된다. (2pc?)  
서비스가 쉽게 다운되지 않도록 단일 장애점을 없도록 하는 것이 중요하다. DeNA에서는 MySQL의 복제 기능을 채용하고 마스터/다중 슬레이브 구성을 취해서, 슬레이브 한 개가 고장나도 서비스를 계속할 수 있다고 한다. 마스터는 단일 장애점이 되지만, 다운되면 자동으로 빠른 장애 조치 매커니즘을 제공해서 실질적인 다운 타임을 30초 정도로 막고 있다.  

#### 양질의 문서/품질/보급도를 충족할 것  

오랫동안 다양한 환경에서 사용되어 왔고, 제품이 널리 보급되어 있는 것 자체가 문서와 제품의 품질을 높이는 데도 역할을 하고 있다. 양질의 문서를 제공하기 때문에 제품의 소스코드를 보지 않고도 습득할 수 있고, 시행착오와 불필요한 논쟁을 줄여준다.  
